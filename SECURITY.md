# üîê Guide de S√©curit√© - Configuration des API Keys

## Vue d'ensemble de la S√©curit√©

Ce guide d√©taille la configuration s√©curis√©e des 8 fournisseurs LLM support√©s par l'Orchestrator Agent, avec les meilleures pratiques de s√©curit√© pour la gestion des cl√©s API.

## üîë Configuration des Variables d'Environnement

### Variables Requises

| Provider | Variable d'Environnement | Format Attendu | Exemple |
|----------|-------------------------|----------------|---------|
| **OpenAI** | `OPENAI_API_KEY` | `sk-[a-zA-Z0-9]{48}` | `sk-proj-abc123...` |
| **Anthropic** | `ANTHROPIC_API_KEY` | `sk-ant-api03-[a-zA-Z0-9-_]{95}` | `sk-ant-api03-xyz789...` |
| **Google Gemini** | `GEMINI_API_KEY` | `AIzaSy[a-zA-Z0-9_-]{33}` | `AIzaSyABC123...` |
| **Mistral** | `MISTRAL_API_KEY` | `[a-zA-Z0-9]{32}` | `abcd1234efgh5678...` |
| **Grok (xAI)** | `GROK_API_KEY` | `xai-[a-zA-Z0-9]{40}` | `xai-abc123def456...` |
| **Qwen** | `QWEN_API_KEY` | `sk-[a-zA-Z0-9]{48}` | `sk-abc123def456...` |
| **DeepSeek** | `DEEPSEEK_API_KEY` | `sk-[a-zA-Z0-9]{48}` | `sk-abc123def456...` |
| **Kimi K2** | `KIMI_K2_API_KEY` | `sk-[a-zA-Z0-9]{48}` | `sk-abc123def456...` |

### Fichier .env S√©curis√©

```env
# ===================================================
# üîê ORCHESTRATOR AGENT - CONFIGURATION S√âCURIS√âE
# ===================================================

# ü§ñ OpenAI Configuration
# Utilis√© pour: GPT-3.5-turbo, GPT-4, GPT-4o, O1-preview
OPENAI_API_KEY=sk-proj-your_openai_key_here
OPENAI_ORG_ID=org-your_org_id_here  # Optionnel

# üß† Anthropic Configuration  
# Utilis√© pour: Claude 3.5 Sonnet, Claude 3.5 Haiku
ANTHROPIC_API_KEY=sk-ant-api03-your_anthropic_key_here

# üîç Google Gemini Configuration
# Utilis√© pour: Gemini 1.5 Pro, Gemini 1.5 Flash
GEMINI_API_KEY=AIzaSyYour_gemini_key_here

# üéØ Mistral Configuration
# Utilis√© pour: Mistral Large, Mistral Small
MISTRAL_API_KEY=your_mistral_key_here

# üöÄ Grok (xAI) Configuration
# Utilis√© pour: Grok-beta
GROK_API_KEY=xai-your_grok_key_here

# üèÆ Qwen Configuration
# Utilis√© pour: Qwen-turbo, Qwen-plus
QWEN_API_KEY=sk-your_qwen_key_here

# üî¨ DeepSeek Configuration
# Utilis√© pour: DeepSeek V3
DEEPSEEK_API_KEY=sk-your_deepseek_key_here

# üåô Kimi K2 Configuration
# Utilis√© pour: Moonshot V1
KIMI_K2_API_KEY=sk-your_kimi_k2_key_here

# ===================================================
# üõ°Ô∏è CONFIGURATION DE S√âCURIT√â AVANC√âE
# ===================================================

# Limitation de rate (optionnel)
MAX_REQUESTS_PER_MINUTE=100
SESSION_TIMEOUT_MINUTES=30

# Monitoring et alertes
ENABLE_API_MONITORING=true
ALERT_EMAIL=admin@yourcompany.com

# Environnement
ENVIRONMENT=production  # development, staging, production
DEBUG_MODE=false
```

## üõ°Ô∏è S√©curit√© par Niveau d'Environnement

### üîß D√©veloppement Local

```bash
# Fichier .env.development
OPENAI_API_KEY=sk-dev-your_dev_key
ANTHROPIC_API_KEY=sk-ant-dev-your_dev_key
# ... autres cl√©s de d√©veloppement

# Variables de debug activ√©es
DEBUG_MODE=true
LOG_LEVEL=DEBUG
CORS_ORIGINS=["http://localhost:3000", "http://localhost:8080"]
```

### üß™ Environnement de Test

```bash
# Fichier .env.testing
# Utilisation de cl√©s API limit√©es pour les tests
OPENAI_API_KEY=sk-test-limited_key
ANTHROPIC_API_KEY=sk-ant-test-limited_key

# Limitations strictes pour les tests
MAX_TOKENS_PER_REQUEST=100
RATE_LIMIT_TEST=10
```

### üöÄ Production

```bash
# Configuration via gestionnaire de secrets cloud
# AWS Secrets Manager, Azure Key Vault, Google Secret Manager

# Variables d'environnement inject√©es par l'orchestrateur
# Kubernetes secrets, Docker secrets, etc.

# Aucune cl√© en clair dans les fichiers !
```

## üè¢ Gestionnaires de Secrets Cloud

### AWS Secrets Manager

```python
import boto3
import json

def get_llm_secrets():
    """R√©cup√®re les cl√©s API depuis AWS Secrets Manager"""
    secrets_client = boto3.client('secretsmanager', region_name='us-east-1')
    
    try:
        response = secrets_client.get_secret_value(SecretId='orchestrator-agent/llm-keys')
        secrets = json.loads(response['SecretString'])
        
        return {
            'OPENAI_API_KEY': secrets.get('openai_key'),
            'ANTHROPIC_API_KEY': secrets.get('anthropic_key'),
            'GEMINI_API_KEY': secrets.get('gemini_key'),
            # ... autres cl√©s
        }
    except Exception as e:
        print(f"Erreur r√©cup√©ration secrets: {e}")
        return {}

# Configuration dans main.py
if os.getenv('ENVIRONMENT') == 'production':
    secrets = get_llm_secrets()
    for key, value in secrets.items():
        os.environ[key] = value
```

### Azure Key Vault

```python
from azure.keyvault.secrets import SecretClient
from azure.identity import DefaultAzureCredential

def get_azure_secrets():
    """R√©cup√®re les cl√©s depuis Azure Key Vault"""
    credential = DefaultAzureCredential()
    client = SecretClient(vault_url="https://orchestrator-kv.vault.azure.net/", credential=credential)
    
    secrets = {}
    secret_names = [
        'openai-api-key', 'anthropic-api-key', 'gemini-api-key',
        'mistral-api-key', 'grok-api-key', 'qwen-api-key',
        'deepseek-api-key', 'kimi-k2-api-key'
    ]
    
    for secret_name in secret_names:
        try:
            secret = client.get_secret(secret_name)
            env_name = secret_name.upper().replace('-', '_')
            secrets[env_name] = secret.value
        except Exception as e:
            print(f"Erreur r√©cup√©ration {secret_name}: {e}")
    
    return secrets
```

### Google Secret Manager

```python
from google.cloud import secretmanager

def get_google_secrets():
    """R√©cup√®re les cl√©s depuis Google Secret Manager"""
    client = secretmanager.SecretManagerServiceClient()
    project_id = "your-project-id"
    
    secrets = {}
    secret_names = [
        'openai-api-key', 'anthropic-api-key', 'gemini-api-key',
        'mistral-api-key', 'grok-api-key', 'qwen-api-key',
        'deepseek-api-key', 'kimi-k2-api-key'
    ]
    
    for secret_name in secret_names:
        try:
            name = f"projects/{project_id}/secrets/{secret_name}/versions/latest"
            response = client.access_secret_version(request={"name": name})
            secret_value = response.payload.data.decode("UTF-8")
            env_name = secret_name.upper().replace('-', '_')
            secrets[env_name] = secret_value
        except Exception as e:
            print(f"Erreur r√©cup√©ration {secret_name}: {e}")
    
    return secrets
```

## üîç Validation et Monitoring des Cl√©s

### Validation Automatique

```python
import re
from typing import Optional, Dict, Any

class APIKeyValidator:
    """Validateur de format des cl√©s API"""
    
    PATTERNS = {
        'openai': r'^sk-[a-zA-Z0-9]{48}$',
        'anthropic': r'^sk-ant-api03-[a-zA-Z0-9\-_]{95}$',
        'gemini': r'^AIzaSy[a-zA-Z0-9_\-]{33}$',
        'mistral': r'^[a-zA-Z0-9]{32}$',
        'grok': r'^xai-[a-zA-Z0-9]{40}$',
        'qwen': r'^sk-[a-zA-Z0-9]{48}$',
        'deepseek': r'^sk-[a-zA-Z0-9]{48}$',
        'kimi_k2': r'^sk-[a-zA-Z0-9]{48}$'
    }
    
    @classmethod
    def validate_key(cls, provider: str, api_key: str) -> bool:
        """Valide le format d'une cl√© API"""
        if not api_key or provider not in cls.PATTERNS:
            return False
        
        pattern = cls.PATTERNS[provider]
        return bool(re.match(pattern, api_key))
    
    @classmethod
    def validate_all_keys(cls) -> Dict[str, Any]:
        """Valide toutes les cl√©s configur√©es"""
        results = {}
        
        for provider, pattern in cls.PATTERNS.items():
            env_var = f"{provider.upper()}_API_KEY"
            api_key = os.getenv(env_var)
            
            results[provider] = {
                'configured': api_key is not None,
                'valid_format': cls.validate_key(provider, api_key) if api_key else False,
                'length': len(api_key) if api_key else 0
            }
        
        return results

# Utilisation au d√©marrage
def startup_security_check():
    """V√©rifications de s√©curit√© au d√©marrage"""
    validation_results = APIKeyValidator.validate_all_keys()
    
    invalid_keys = []
    for provider, result in validation_results.items():
        if result['configured'] and not result['valid_format']:
            invalid_keys.append(provider)
    
    if invalid_keys:
        raise ValueError(f"Cl√©s API invalides d√©tect√©es: {invalid_keys}")
    
    print("‚úÖ Validation des cl√©s API r√©ussie")
    return validation_results
```

### Monitoring des Usages

```python
import time
from collections import defaultdict
from datetime import datetime, timedelta

class APIUsageMonitor:
    """Moniteur d'usage des APIs"""
    
    def __init__(self):
        self.usage_stats = defaultdict(lambda: {
            'requests_count': 0,
            'tokens_used': 0,
            'errors_count': 0,
            'last_request': None,
            'cost_estimate': 0.0
        })
    
    def record_request(self, provider: str, tokens_used: int = 0, 
                      cost: float = 0.0, error: bool = False):
        """Enregistre une utilisation d'API"""
        stats = self.usage_stats[provider]
        stats['requests_count'] += 1
        stats['tokens_used'] += tokens_used
        stats['cost_estimate'] += cost
        stats['last_request'] = datetime.now()
        
        if error:
            stats['errors_count'] += 1
    
    def get_daily_report(self) -> Dict[str, Any]:
        """G√©n√®re un rapport quotidien d'usage"""
        return {
            'timestamp': datetime.now().isoformat(),
            'providers': dict(self.usage_stats),
            'total_requests': sum(stats['requests_count'] for stats in self.usage_stats.values()),
            'total_cost': sum(stats['cost_estimate'] for stats in self.usage_stats.values()),
            'total_errors': sum(stats['errors_count'] for stats in self.usage_stats.values())
        }
    
    def check_rate_limits(self, provider: str, max_requests_per_hour: int = 100) -> bool:
        """V√©rifie les limites de taux"""
        stats = self.usage_stats[provider]
        if not stats['last_request']:
            return True
        
        hour_ago = datetime.now() - timedelta(hours=1)
        # Logique simplifi√©e - en production, utiliser une vraie fen√™tre glissante
        return stats['requests_count'] < max_requests_per_hour

# Instance globale
usage_monitor = APIUsageMonitor()
```

## üö® Alertes de S√©curit√©

### Configuration des Alertes

```python
import smtplib
from email.mime.text import MIMEText
from typing import List

class SecurityAlerter:
    """Syst√®me d'alertes de s√©curit√©"""
    
    def __init__(self, smtp_server: str, smtp_port: int, email: str, password: str):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.email = email
        self.password = password
        
        # Seuils d'alerte
        self.thresholds = {
            'error_rate': 0.05,  # 5% d'erreurs
            'requests_per_minute': 100,
            'unusual_cost_spike': 10.0,  # $10/heure
            'failed_auth_attempts': 5
        }
    
    def send_alert(self, subject: str, message: str, recipients: List[str]):
        """Envoie une alerte par email"""
        try:
            msg = MIMEText(message)
            msg['Subject'] = f"üö® ORCHESTRATOR SECURITY ALERT: {subject}"
            msg['From'] = self.email
            msg['To'] = ', '.join(recipients)
            
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.email, self.password)
                server.send_message(msg)
                
            print(f"‚úÖ Alerte envoy√©e: {subject}")
        except Exception as e:
            print(f"‚ùå Erreur envoi alerte: {e}")
    
    def check_security_metrics(self, metrics: Dict[str, Any]):
        """V√©rifie les m√©triques de s√©curit√©"""
        alerts = []
        
        # V√©rification du taux d'erreur
        total_requests = metrics.get('total_requests', 0)
        total_errors = metrics.get('total_errors', 0)
        if total_requests > 0:
            error_rate = total_errors / total_requests
            if error_rate > self.thresholds['error_rate']:
                alerts.append(f"Taux d'erreur √©lev√©: {error_rate:.2%}")
        
        # V√©rification des co√ªts
        total_cost = metrics.get('total_cost', 0)
        if total_cost > self.thresholds['unusual_cost_spike']:
            alerts.append(f"Pic de co√ªt inhabituel: ${total_cost:.2f}")
        
        # Envoyer les alertes
        if alerts:
            message = "Anomalies d√©tect√©es:\n" + "\n".join(f"- {alert}" for alert in alerts)
            self.send_alert("Anomalies D√©tect√©es", message, ["admin@company.com"])

# Configuration
security_alerter = SecurityAlerter(
    smtp_server="smtp.gmail.com",
    smtp_port=587,
    email=os.getenv("ALERT_EMAIL"),
    password=os.getenv("ALERT_EMAIL_PASSWORD")
)
```

## üîÑ Rotation des Cl√©s

### Script de Rotation Automatis√©e

```python
import schedule
import time
from datetime import datetime, timedelta

class KeyRotationManager:
    """Gestionnaire de rotation des cl√©s"""
    
    def __init__(self):
        self.rotation_schedule = {
            'openai': timedelta(days=30),
            'anthropic': timedelta(days=30),
            'gemini': timedelta(days=30),
            'mistral': timedelta(days=30),
            'grok': timedelta(days=30),
            'qwen': timedelta(days=30),
            'deepseek': timedelta(days=30),
            'kimi_k2': timedelta(days=30)
        }
        
        self.last_rotation = {}
    
    def should_rotate_key(self, provider: str) -> bool:
        """D√©termine si une cl√© doit √™tre renouvel√©e"""
        if provider not in self.last_rotation:
            return True
        
        last_rotation = self.last_rotation[provider]
        rotation_interval = self.rotation_schedule[provider]
        
        return datetime.now() - last_rotation > rotation_interval
    
    def rotate_key(self, provider: str):
        """Effectue la rotation d'une cl√©"""
        print(f"üîÑ Rotation de la cl√© {provider}...")
        
        # 1. G√©n√©rer nouvelle cl√© via API du provider
        # 2. Mettre √† jour le gestionnaire de secrets
        # 3. Tester la nouvelle cl√©
        # 4. D√©sactiver l'ancienne cl√©
        # 5. Notifier les √©quipes
        
        self.last_rotation[provider] = datetime.now()
        print(f"‚úÖ Cl√© {provider} renouvel√©e avec succ√®s")
    
    def check_all_keys(self):
        """V√©rifie et renouvelle toutes les cl√©s n√©cessaires"""
        for provider in self.rotation_schedule:
            if self.should_rotate_key(provider):
                self.rotate_key(provider)

# Planification automatique
rotation_manager = KeyRotationManager()
schedule.every().week.do(rotation_manager.check_all_keys)

def run_rotation_scheduler():
    """Lance le planificateur de rotation"""
    while True:
        schedule.run_pending()
        time.sleep(3600)  # V√©rification chaque heure
```

## üîí Checklist de S√©curit√©

### ‚úÖ Configuration Initiale

- [ ] Toutes les 8 cl√©s API configur√©es
- [ ] Validation des formats de cl√©s
- [ ] Fichier .env ajout√© √† .gitignore
- [ ] Gestionnaire de secrets configur√© (prod)
- [ ] Permissions d'acc√®s restreintes

### ‚úÖ Monitoring

- [ ] Syst√®me d'alertes configur√©
- [ ] M√©triques d'usage activ√©es
- [ ] Logs s√©curis√©s (pas de cl√©s en clair)
- [ ] Monitoring des taux d'erreur
- [ ] Surveillance des co√ªts

### ‚úÖ S√©curit√© Op√©rationnelle

- [ ] Rotation automatique des cl√©s
- [ ] Backup des configurations
- [ ] Tests de basculement
- [ ] Documentation √† jour
- [ ] Formation √©quipes

### ‚úÖ Conformit√©

- [ ] Audit de s√©curit√© r√©gulier
- [ ] Respect RGPD/CCPA
- [ ] Logs d'audit complets
- [ ] Certification s√©curit√©
- [ ] Politique de r√©tention des donn√©es

---

## üìû Support S√©curit√©

**Contact S√©curit√© :** security@yourcompany.com  
**Urgences 24/7 :** +1-XXX-XXX-XXXX  
**Documentation :** https://docs.orchestrator-agent.com/security  

---

> üõ°Ô∏è **La s√©curit√© n'est pas une option, c'est une n√©cessit√©.** Ce guide assure une configuration s√©curis√©e de votre plateforme Orchestrator Agent.